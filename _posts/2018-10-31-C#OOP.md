---
layout: post
title: Object-oriented programming for C# 
date: 2018-10-31
categories: blog
tags: OOP
description: OOP
---

# C#面向对象编程

## 一、前言

为了完成科创计划的项目需要学习WPF编程，在学习WPF之前复习一些以C#为基础的面向对象的知识

---

## 二、继承

### 2-2 隐藏方法

子类继承父类后，不能删除基类中的任何成员，但是可以用与基类成员名称相同的成员来屏蔽基类成员——隐藏方法

隐藏方法：
- 屏蔽数据成员：在派生类中声明名称和类型相同的成员
- 屏蔽函数成员：在派生类中声明新的带有相同函数签名(参数列表相同和函数名相同，并不包括返回类型）的成员
- 让编译器知道：可以添加new关键字，否则会有警告

注意，C++可以多继承，C#只能单继承。

### 2-3 虚方法和多态

一个设计原则：

面向对象编程中，都遵循一个原则：依赖倒置原则。就是程序设计要依赖于抽象类（Pet），而不依赖于具体类（Dog）；

基类的引用：

派生类对象包含基类部分和派生类部分，所以我们可以通过一个基类类型的引用指向派生类。例如Pet dog=new Dog();  但是通过指向派生类的基类引用，我们仅仅能访问派生类中的基类部分。

虚方法：声明为virtual的方法就是虚方法。基类的虚方法可以在派生类中使用override进行重写

多态：通过指向派生类的基类引用，调用虚函数，会根据引用所指向派生类的实际类型，调用派生类中的同名重写函数，便是多态。

关于虚方法：

①重写虚方法必须具有相同的可访问性，且基类方法不能是private 

②不能重写static方法或者非虚方法

### 2-5 抽象方法和抽象类

区别于虚方法，虚方法允许派生类中不重写，但抽象方法不可以。这是由于在基类中定义抽象方法时，不允许定义函数实体，所以必须在派生里override

含有抽象方法的类是抽象类，抽象类可以包含抽象成员和普通成员，抽象类的抽象成员在派生类中必须用override实现。抽象类在声明之前必须加上abstract。抽象类的存在只有一个目的->就是被继承。抽象类不能被实例化。

### 2-6 密闭类和密闭方法

密闭类：声明为sealed的类。有些类不希望其他人通过继承来修改

密闭方法：声明为sealed的方法。不希望其他人重写该方法。

如果一个基类方法不希望子类对其重写，就可以不声明为virtual。如果是某个派生类方法不希望子类对其重写，同时是override重写，就可以使用sealed机制。

### 2-7 接口

接口就是制定一组函数成员，而不实现他们的引用类型，用interface声明。接口函数不能用其他访问修饰符修饰，默认为public。

接口只能用来被实现，由继承它的类帮助它实现。

一个类可以实现多个接口。

### 2-8 结构和类

不同点：结构是值类型（在栈中），类是引用类型（在堆中）

结构不支持继承，类支持继承

结构不能定义默认构造函数，编译器会定义

适用场合：

- 结构：用于分配内存块，作用域结束即被删除，不需要垃圾回收，用于小型数据结构。但要注意传递过程中会复制，应该使用ref进行参数传递
- 类：用于其他的需要继承体系的场合

## 三、静态成员和静态类

### 3-1 静态成员

标识为static的字段，方法，属性，构造函数，事件，就是静态成员。

静态字段将被类的所有实例共享，所有实例都访问同一内存位置

静态成员和实例成员在内存中分开保存

静态成员仅和整个类有关，将直接通过类名访问（而不是通过实例）

静态成员的生存期：独立于任何实例，没有实例也可以访问，其初始化语句在任何静态成员使用之前调用。

静态函数成员：静态函数也独立于任何实例，没有实例也可以调用。静态函数不能访问实例成员，仅能访问其他静态成员。但是反过来，实例成员可以访问静态成员。（因为静态成员独立于实例，有静态不一定有实例，所以不能依赖于实例来访问）

静态构造函数：静态构造函数用于初始化静态字段（为静态成员而生）

静态构造函数在引用任何静态成员和创建任何实例之前就会被调用。

静态构造函数与类同名，使用static，没有参数，没有访问修饰符

### 3-2 静态类

如果类只包含了静态的方法和属性，并且标识为static，那么这个类就是静态类。

静态类不能创建实例，不能被继承（相当于sealed）

可以为静态类定义一个静态构造函数来初始化静态成员

静态类用来做什么：主要用于基础类库（如数学库）和扩展方法。

如何扩展方法：
- 如果有源代码，直接添加一个新方法。
- 如果不能修改源代码但也不是密闭类，可以派生子类扩展
- 如果既不能修改源代码也是密闭类，可以使用静态类扩展方法 

静态类扩展方法的要求：
- 扩展方法所属的类必须是static类
- 扩展方法本身必须是static方法
- 扩展方法的第一个参数类型，必须是this+类名


## 四、重载操作符 

### 4-1 装箱和拆箱

装箱：根据值类型的值，在堆上创建一个完整的引用类型对象，并返回对象的引用，是一种隐式转换。（值类型转换为引用类型）

装箱的原因：有时候需要将值类型转换为引用类型，来进行统一的操作和统一的存储。比如作为函数的参数时要进行统一的操作。

举例：

```
int i=3;
object oi=null;
oi=i; //这就是装箱的操作
```

![](https://github.com/yaowenqing/blog.io/blob/master/img/OOP1.png)

装箱的本质：就是在堆上创建了引用类型的副本，新创建的引用类型和原来的值类型相互独立。

拆箱：将装箱后的对象转换为值类型的过程，是一种显式转换，需要手动完成

拆箱示例：

```
int i=3;
object oi=i;
int j=(int) oi;
```

### 4-2 自定义转换

什么是自定义转换：为自己的结构或者类定义显式和隐式转换

为什么要自定义转换：为了让我们自己的结构或者类可以变成一个预期相关的类型，并且使这种转换更加简单。

比如把猫咪类转化成狗狗类

隐式转换的语法（本质上是定义一个静态方法）

```
public static implicit operator Dog(Cat cat){}
```

（其中implicit表示这是隐式转换 operator标明这是一种操作 Dog是返回类型 没有函数名）

显式转换的语法：

```
public static explicit operator Dog(Cat cat){}
```

隐式转换举例：

```
public static implicit operator Dog(Cat cat){
  return new Dog(cat_name);
}
Cat cat=new Cat(“Jack”);
Dog dog=cat; //由于是隐式转换，所以可以直接转换
```

显式转换举例：

```
public static explicit operator Dog(Cat cat){
  return new Dog(cat_name);
}
Dog dog2=(Dog)cat;//由于是显式转换，所以需要手动强制转换
```

### 4-3 重载运算符

什么是重载运算符：利用现有的某种运算符，针对自定义类或者结构，定义某种运算操作。

（不能创造新的运算符；预定义类型和现有运算符的运算含义是确定的，即不可改变运算原有规则，如加变减。）

为什么需要重载运算符：利用现有运算符，简化自定义类型的操作。最好是该运算符和该操作之间具有一定的相关性。

语法细节：（以公狗狗和母狗狗生小狗狗为例来重载加法运算

```
public static Dog operator+(Dog male,Dog female){...}
```

重载运算符时一元运算符的操作数必须是类或结构，二元运算符的两个操作数必须至少有一个是类或结构

不能重载的运算符：=,&&,||,[],()等等 

重载运算符不能做的事情：
- 创造新运算符
- 改变运算符语法
- 重定义运算符如何处理预定义的类型（例如加变减）
- 改变运算符的优先级和结合性

举例：（给宠物的年龄自增）

```
public static Pet operator ++(Pet pet){
  ++pet.age;
  return pet;
}

for(int i=0;i<pets.Length;++i){
  pets[i]++; //就通过重载++运算符完成了对宠物年龄的自增操作
}
```

## 五、泛型 

### 5-1 泛型类

泛型类就是一个模子，装入类型的材料，可以塑造出想要的产品。

泛型类：装载同类型类的容器，实例化泛型类后依靠泛型类内中的方法连续处理相同类型的类

下面的代码是一个宠物笼子的模型，在<T>中填充对应的宠物类型可以得到专属的笼子

```
class Cage<T>{
    T[] petsArray;
    public void PutIn(T pet){……}
    public T TakeOut(int index){……}
}
```

为什么需要泛型呢？

下面的是一个狗狗的笼子类

```
class DogCage{
    Dog[] petsArray;
    public void PutIn(Dog pet){……}
    public Dog TakeOut(int index){……}
}
```

如果笼子里要装猫咪、豚鼠等其他宠物，还要重新写其他宠物的笼子类。

可是如果有泛型类的话，可以直接写

```
var dogCage=new Cage<Dog>(); 
```

用基类或者公共的接口，甚至是所有类的基类object也可以实现一个Cage类，但是类型太宽泛，需要显式转换类型，并且需要判断真实类型是什么。

泛型类的实例化

```
class Cage<T>{...}		//泛型类声明 
Cage<Dog> dogCage;	//Cage<Dog>类型的引用
dogCage=new Cage<Dog>();	//构造实例
```

泛型类的优势：
- 代码量更小，无论多少种笼子，我们只需要一个实现
- 只有需要的类型才会被实例化
- 易于维护，只要修改模板，所有的实例都将改变

举例：

```
public class Cage<T>{
  T[]array;
  int size;
  int num;
  public Cage(int n){
    size=n;
    num=0;
    array=new T[size];
  }
  public void Putin(T pet){
    array[num++]=pet;
  }
  public T TakeOut(){
    return array[--num];
  }
}


var dogCage=new Cage<Dog>(2);
dogCage.Putin(new Dog(“A”));
```

### 5-2 泛型方法

泛型方法就是方法的模型，给定具体的类型就可以实例化出一个操作该类型的具体方法。

泛型类中往往有泛型方法，普通类中也可以有泛型方法。

### 5-3 约束

约束就是控制泛型这匹烈马的缰绳，缩小泛型参数的范围。

只有添加了约束，才能调用泛型参数中的方法。

约束的类型：

A.主约束（只能传入一个） 有类名、class、struct三种

类名→约束为只能传入该类或者继承该类的类

class→可以传入任何类

struct→可以传入任何值

B.接口约束（可以传入任意多个）

接口名→约束为只能传入该接口类型或任何实现该接口的类型

C.构造约束

new()→带有无参数共有构造函数的类

举例：

```
void Cage<T> where T:Pet,IClimbTree,new(){...}
```

对T的约束：T必须是Pet或其派生类，而且必须实现了爬树接口，且有默认构造函数

### 5-4 泛型接口

泛型接口：泛型接口允许我们将接口成员的参数和返回类型设置为泛型参数的接口

语法:

```
interface IMyself<T>{
T Myself(T self);
}
```

实现泛型接口的语法

```
class A:IMyself<A>{
public A Myself(A self);
}
```

## 六、集合 

什么是集合：集合是一种存放多个数据的容器类型，比如Array

预定义的常用集合：

- 动态数组ArrayList
- 列表List
- 字典Dictionary
- 队列Queue
- 栈Stack

集合的好处：比数组更加强大，实现了更加丰富的功能，提高开发效率

**动态数组ArrayList**

初始化的时候可以不指定大小

获取数组大小使用Count属性

可以使用Add来添加

删除使用Remove（删除对象）和RemoveAt（删除对象所在的索引）

访问[index]

缺点：比数组耗费更多的内存，里面存放的object类型需要装箱拆箱操作

**更好用的List<T>**

ArrayList是类型不安全的，而且有装箱拆箱的性能问题

但是List<T>的存取速度还是会比较慢

使用举例：

```
List<Dog> list = new List<Dog>();
list.Add(new Dog(’’A’’));
```

**字典Dictionary<TKey,Tvalue>**

字典容器存储的是一系列的键值对，每个值对应一个唯一的键。键的意义在于，我们可以通过键高效地访问到值。

字典操作：
- 数量 Count
- 添加 Add(key,value)
- 删除 Remove
- 访问 [key] //可以通过键来访问

使用举例：

```
Dictionary<string,Dog> dic =new Dictionary<string,Dog>();
dic.Add(“A”,new Dog(“A”));
dic[“A”].printName();
```

**栈：先进后出的一种容器**

栈的操作：
- 出栈：Pop
- 入栈：Push
- 获取栈顶元素：Peek
使用举例：

```
Stack<Pet> stack=new Stack<Pet>();
stack.Push(new Dog(“A”));
stack.Push(new Cat(“B”));
stack.Peek().PrintName(); //输出B
```

**队列：先进先出的一种容器**

队列的操作：
- 出队：Dequeue
- 入队：Enqueue

## 七、委托

### 7-1 委托

什么是委托：委托就是持有一个或者多个方法的对象。并且该对象可以执行，可以传递。

声明委托类型：（委托可以声明，它是一种引用类型）

```
delegate void ActCute();
```

定义委托类型的对象：

```
ActCute actCute;
```

给委托对象赋值：

```
class Dog{
	public void WagTail(){…}
} 
actCute=dog.WagTail;  //委托对象就持有了狗狗的摇尾巴的方法
actCute+=cat.LovelyLook; //委托可以持有多个方法
```

使用委托类型：像调用函数一样使用委托类型

```
actCute();
```

委托可以持有多个方法，当委托持有多个方法时，我们调用一次委托相当于调用了委托所持有的所有方法。

### 7-2 Lambda表达式

匿名方法：（C#2.0） 

声明委托类型：

```
delegate void ActCute();
```

定义委托类型的对象：

```
ActCute actCute;
```

声明匿名方法：

```
actCute =delegate(){…}; //delegate+匿名方法的参数列表
```

Lambda表达式（C#3.0）

声明匿名方法的语句更换为：

```
actCute=()=>{…};
```

应用举例：

```
del+=()=>{
	Console.WriteLine(“do nothing”); //随后调用名为del的委托时会输出这句话
}
```

### 7-3 事件（观察者设计模式）

发布者和订阅者：

- 通知某件事情发生的，就是发布者。
- 对某件事情关注的，就是订阅者。

事件触发和注册

- 事件发生时，会通知所有关注该事件的订阅者。
- 想在事件发生时被通知，必须注册以表示关注。

用程序语言解释:

事件发生时通知订阅者就是调用订阅者的注册函数。注册，就是告诉发布者调用哪一个注册函数。

事件声明：

```
delegate void Handler();
public event Handler NewDog; //这里NewDog相当于被观察者，被通知宠物商店有新狗狗的顾客是观察者
```

NewDog是一个成员，并且会被隐式自动初始化为null 

事件订阅：

NewDog+=方法; //订阅

NewDog-=方法; //取消订阅

其中方法可以是实例方法、静态方法、匿名方法、Lambda表达式

事件触发：

```
if(NewDog!=null){
	NewDog(); 
}
```

![](https://github.com/yaowenqing/blog.io/blob/master/img/OOP2.png)
