---
layout: post
title: 操作系统——存储器管理
date: 2018-06-24
categories: blog
tags: 操作系统
description: 学习笔记。
---

## 前言

`操作系统原理`是武汉大学计算机学院软件工程专业大二下半学期所学习的一门专业课，教材为西安电子科技大学出版社的`计算机操作系统`第4版，这个专题的博客为该课程的学习笔记，该博客的主要内容是**存储器管理**
---
## 存储器的层次结构

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_26.png)

寄存器和主存储器被称为可执行存储器.进程可以在很少的时钟周期内使用一条load或store指令对可执行存储器进行访问，但对辅存的访问则需要通过I/O设备实现。

### 主存储器与寄存器

主存储器（主存、内存）
  - 保存进程运行时的程序和数据
寄存器
  - 访问速度最快、容量小、价格昂贵
  - 位于CPU内，暂存指令、地址、数据等
  
### 高速缓存和磁盘缓存
高速缓存
  - 容量大于寄存器，速度快于主存
  - 主要用于备份主存中较常用的数据，以减少处理机对主存储器的访问次数
  - 利用程序执行的局部性原理，经主存中经常要用到的信息存放在高速缓存中，减少访问主存的次数。
磁盘缓存
  - 为了缓和磁盘的I/O速度远低于对主存的访问速度这一不匹配的关系而设置。
  - 将频繁使用的磁盘数据暂时存放在磁盘缓存中，可以减少访问磁盘的次数

---
## 程序的装入和链接
用户程序转变为一个可以执行的程序经过以下几个步骤：编译、链接、装入

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_27.png)

### 程序的装入

为了阐述方便，先介绍一个无需进行链接的单个目标模块的装入过程，在将一个单个装入模块装入内存时可以有如下三种装入方式：

1. 绝对装入方式(Absolute Loading Mode) 

目标模块采用绝对地址。即逻辑地址和实际内存地址完全相同，装入时不需对地址进行变换。

特点：适用于单道环境。

2. 可重定位装入方式(Relocation Loading Mode)

多道环境下，目标模块的起始地址通常从0开始。根据内存的当前情况，将目标模块装入到内存适当位置。采用静态地址变换。

静态地址变换：又称静态地址重定位，地址变换在程序装入时一次完成，以后不再改变。

特点：不需硬件支持，但程序运行时不能在内存移动，程序需要连续存储空间，难以共享。

3. 动态运行时装入方式(Dynamic Run-time Loading)

动态运行时的装入程序，在把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此， 装入内存后的所有地址都仍是相对地址。 

特点：需要重定位寄存器支持。程序可以在内存中移动，可以实现虚拟存储。.

### 程序的链接

源程序编译后得到一组目标模块，链接程序的功能是将这组目标模块以及它们所需要的库函数装配成一个完整的装入模块。在对目标模块进行链接时，根据进行链接的时间不同，可把链接分成如下三种：

1. 静态链接

程序运行前，先将各目标模块以及它们所需的库函数，链接成一个完整的装入模块，不再拆开。

2. 装入时动态链接

在装入时采用边装入边链接的方式装入。

优点：便于修改和更新；便于实现目标模块共享

3. 运行时动态链接

对模块的链接推迟到程序执行时才去进行链接。

优点：加快装入过程；节省内存空间

---
## 连续分配存储管理方式

连续分配方式，是指为一个用户程序分配一个连续的内存空间。包括：

单一连续分配、固定分区分配、动态分区分配、动态重定位分配

### 单一连续分配

  - 把内存分为系统区和用户区两部分，系统区仅提供给OS使用，通常是放在内存的低址部分；用户区是指除系统区以外的全部内存空间， 提供给用户使用。 
  - 特点：最简单；适用于单用户、单任务的OS
  
### 固定分区分配

  - 固定分区分配是多道程序系统中采用的一种最简单的存储管理方法。预先将内存空间划分为若干个固定大小的分区，每个分区中可以装入一道程序。分区的位置及大小在运行期间不能改变。
      各分区的大小可以相等，也可以不相等。
  - 两个固定：
    - 各分区的大小固定不变
    - 总分区的个数固定不变
 ![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_28.png)   

**内存分配和回收**

分区分配：当有用户程序要装入时，由内存分配程序检索分区使用表，从中找出一个能满足要求的空闲分区分配给该程序，然后修改分区说明表中相应表项的状态；若找不到大小足够的分区，则拒绝分配内存。

分区回收：当程序执行完毕不再需要内存资源时，释放程序占用的分区，管理程序只需将对应分区的状态置为未分配即可。

固定分区分配的优缺点：
- 是最早采用，也是最简单的多道程序存储管理方式。
- 预先规定了分区大小，大程序无法装入。
- 预先限制了活跃进程的最大数。
- 主存的利用率不高：每个分区的作业不可能恰好占满该区，剩余的部分空间又不能为其它作业利用。－碎片问题（内部碎片）
- 内存的扩充和共享是困难的。

### 动态分区分配

- 动态分区分配又称为可变分区分配，这种存储管理方法的实现思想是根据作业大小动态地建立分区，并使分区的大小正好适应作业的需要。因此系统中分区的大小是可变的，分区的数目也是可变的。
- 两个可变：
  - 分区的大小可变；
  - 分区的个数可变。
  
1.常用的的管理空闲分区的数据结构有：

空闲分区表。用一个空闲分区表来登记系统中的空闲分区。其表项类似于固定分区。

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_29.png)  

或者，空闲分区链。将内存中的空闲分区以链表方式链接起来，构成空闲分区链。

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_30.png)

2.动态分区分配回收内存可能出现以下四种情况之一：
- 回收分区r上面邻接一个空闲分区
- 回收分区r下面邻接一个空闲分区
- 回收分区r上面、下面各邻接一个空闲分区
- 回收分区r不与任何空闲分区相邻

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_31.png)
![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_32.png)
![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_33.png)
![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_34.png)

3.动态分区管理的优缺点

- 相对灵活，没有固定分区中程序数目的限制和程序大小的限制。
- 每道程序总是要求占用主存的连续存储区域，主存中会产生许多碎片（外部碎片）。

4.动态分区分配算法

不论是空闲分区链管理还是空闲分区表管理，链和表中的空闲区都可按一定规则排列，例如按空闲区从大到小排，以方便空闲区的查找和回收。

常用的动态分区管理的分配算法有：

1)首次适应算法（FF）

首次适应算法又称最先适应算法，该算法要求空闲分区按地址递增的次序排列。

在进行内存分配时，从空闲分区表（或空闲分区链）首开始顺序查找，直到找到第一个能满足其大小要求的空闲分区为止。

然后，再按照作业大小，从该分区中划出一块内存空间分配给请求者，余下的空闲分区仍然留在空闲分区表（或空闲分区链）中

特点：优先利用内存低地址端，高地址端有大空闲区。但低地址端有许多小空闲分区时会增加查找开销。

2)循环首次适应算法（NF）

循环首次适应算法又称下次适应算法，它是首次适应算法的变形。空闲分区仍然是按地址递增的次序排列。

该算法在为进程分配内存空间时，从上次找到的空闲分区的下一个空闲分区开始查找，直到找到第一个能满足其大小要求的空闲分区为止。

然后，再按照作业大小，从该分区中划出一块内存空间分配给请求者，余下的空闲分区仍然留在空闲分区表（或空闲分区链）中。

特点：使存储空间的利用更加均衡，但会使系统缺乏大的空闲分区。

3)最佳适应算法（BF）

最佳适应算法要求空闲分区按容量大小递增的次序排列。

在进行内存分配时，从空闲分区表（或空闲分区链）首开始顺序查找，直到找到第一个能满足其大小要求的空闲分区为止。

如果该空闲分区大于作业的大小，则从该分区中划出一块内存空间分配给请求者，将剩余空闲区插入到空闲分区表（或空闲分区链）中的适当位置。

按最佳适应算法为作业分配内存，就能把既满足作业要求又与作业大小最接近的空闲分区分配给作业。

特点：保留了大的空闲区。但分割后的剩余空闲区很小。

4) 最坏适应算法(WF)

最坏适应算法要求空闲分区按容量大小递减的次序排列。

在进行内存分配时，先检查空闲分区表（或空闲分区链）中的第一个空闲分区，若第一个空闲分区小于作业要求的大小，则分配失败；

否则从该空闲分区中划出与作业大小相等的一块内存空间分配给请求者，余下的空闲分区仍插入到空闲分区表（或空闲分区链）中的适当位置。

特点：分区分配之后剩下的空闲区域（新空闲区）比较大，但当大作业到来时，其存储空间的申请往往得不到满足。

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_35.png)

在该例子中，采用首次适应算法，申请96K的时候把作业分配给4号分区，申请20K的时候分配给1号分区，但申请200K的时候现有的五个分区都无法满足要求，该作业等待。显然采用首次适应算法进行内存分配，无法满足该作业序列的需求。

但采用最佳适应算法则可以满足该作业序列的需求，申请96K时选中5号分区，5号分区大小与申请空间大小一致，应从空闲分区表中删去该表项；然后申请20K时选中1号分区，分配后1号分区还剩下12K；最后申请200K，选中4号分区，分配后剩下18K。

### 动态可重定位分区分配
连续分配方式中，必须把作业装入到一片连续的内存空间中。这种分配方法能满足多道程序设计的需要，但存在碎片问题。 

碎片也可称为零头，是指内存中无法被利用的存储空间。

解决碎片问题的办法

拼接：解决碎片问题的办法之一，即通过移动内存中的进程，把多个分散的小分区拼接成一个大分区，也可称为紧缩或紧凑。
拼接的缺点是要耗费大量处理机时间。每次拼接之后都必须对移动了的程序或数据进行重定位。
