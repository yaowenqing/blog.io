---
layout: post
title: Operating System——Storage Management
date: 2018-06-25
categories: blog
tags: Operating-System
description: Operating System
---

# 操作系统——存储器管理

## 前言

`操作系统原理`是武汉大学计算机学院软件工程专业大二下半学期所学习的一门专业课，教材为西安电子科技大学出版社的`计算机操作系统`第4版，这个专题的博客为该课程的学习笔记，该博客的主要内容是**存储器管理**

---
## 存储器的层次结构

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_26.png)

寄存器和主存储器被称为可执行存储器.进程可以在很少的时钟周期内使用一条load或store指令对可执行存储器进行访问，但对辅存的访问则需要通过I/O设备实现。

### 主存储器与寄存器

主存储器（主存、内存）
  - 保存进程运行时的程序和数据
寄存器
  - 访问速度最快、容量小、价格昂贵
  - 位于CPU内，暂存指令、地址、数据等
  
### 高速缓存和磁盘缓存
高速缓存
  - 容量大于寄存器，速度快于主存
  - 主要用于备份主存中较常用的数据，以减少处理机对主存储器的访问次数
  - 利用程序执行的局部性原理，经主存中经常要用到的信息存放在高速缓存中，减少访问主存的次数。
磁盘缓存
  - 为了缓和磁盘的I/O速度远低于对主存的访问速度这一不匹配的关系而设置。
  - 将频繁使用的磁盘数据暂时存放在磁盘缓存中，可以减少访问磁盘的次数

---
## 程序的装入和链接
用户程序转变为一个可以执行的程序经过以下几个步骤：编译、链接、装入

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_27.png)

### 程序的装入

为了阐述方便，先介绍一个无需进行链接的单个目标模块的装入过程，在将一个单个装入模块装入内存时可以有如下三种装入方式：

1. 绝对装入方式(Absolute Loading Mode) 

目标模块采用绝对地址。即逻辑地址和实际内存地址完全相同，装入时不需对地址进行变换。

特点：适用于单道环境。

2. 可重定位装入方式(Relocation Loading Mode)

多道环境下，目标模块的起始地址通常从0开始。根据内存的当前情况，将目标模块装入到内存适当位置。采用静态地址变换。

静态地址变换：又称静态地址重定位，地址变换在程序装入时一次完成，以后不再改变。

特点：不需硬件支持，但程序运行时不能在内存移动，程序需要连续存储空间，难以共享。

3. 动态运行时装入方式(Dynamic Run-time Loading)

动态运行时的装入程序，在把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此， 装入内存后的所有地址都仍是相对地址。 

特点：需要重定位寄存器支持。程序可以在内存中移动，可以实现虚拟存储。.

### 程序的链接

源程序编译后得到一组目标模块，链接程序的功能是将这组目标模块以及它们所需要的库函数装配成一个完整的装入模块。在对目标模块进行链接时，根据进行链接的时间不同，可把链接分成如下三种：

1. 静态链接

程序运行前，先将各目标模块以及它们所需的库函数，链接成一个完整的装入模块，不再拆开。

2. 装入时动态链接

在装入时采用边装入边链接的方式装入。

优点：便于修改和更新；便于实现目标模块共享

3. 运行时动态链接

对模块的链接推迟到程序执行时才去进行链接。

优点：加快装入过程；节省内存空间

---
## 连续分配存储管理方式

连续分配方式，是指为一个用户程序分配一个连续的内存空间。包括：

单一连续分配、固定分区分配、动态分区分配、动态重定位分配

### 单一连续分配

  - 把内存分为系统区和用户区两部分，系统区仅提供给OS使用，通常是放在内存的低址部分；用户区是指除系统区以外的全部内存空间， 提供给用户使用。 
  - 特点：最简单；适用于单用户、单任务的OS
  
### 固定分区分配

  - 固定分区分配是多道程序系统中采用的一种最简单的存储管理方法。预先将内存空间划分为若干个固定大小的分区，每个分区中可以装入一道程序。分区的位置及大小在运行期间不能改变。
      各分区的大小可以相等，也可以不相等。
  - 两个固定：
    - 各分区的大小固定不变
    - 总分区的个数固定不变
    
 ![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_28.png)   

**内存分配和回收**

分区分配：当有用户程序要装入时，由内存分配程序检索分区使用表，从中找出一个能满足要求的空闲分区分配给该程序，然后修改分区说明表中相应表项的状态；若找不到大小足够的分区，则拒绝分配内存。

分区回收：当程序执行完毕不再需要内存资源时，释放程序占用的分区，管理程序只需将对应分区的状态置为未分配即可。

固定分区分配的优缺点：
- 是最早采用，也是最简单的多道程序存储管理方式。
- 预先规定了分区大小，大程序无法装入。
- 预先限制了活跃进程的最大数。
- 主存的利用率不高：每个分区的作业不可能恰好占满该区，剩余的部分空间又不能为其它作业利用。－碎片问题（内部碎片）
- 内存的扩充和共享是困难的。

### 动态分区分配

- 动态分区分配又称为可变分区分配，这种存储管理方法的实现思想是根据作业大小动态地建立分区，并使分区的大小正好适应作业的需要。因此系统中分区的大小是可变的，分区的数目也是可变的。
- 两个可变：
  - 分区的大小可变；
  - 分区的个数可变。
  
1.常用的的管理空闲分区的数据结构有：

空闲分区表。用一个空闲分区表来登记系统中的空闲分区。其表项类似于固定分区。

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_29.png)  

或者，空闲分区链。将内存中的空闲分区以链表方式链接起来，构成空闲分区链。

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_30.png)

2.**动态分区分配内存**按照动态分区分配算法（下面会讲到）从空闲分区链（表）中找到所需大小的内存并进行分配。

**动态分区分配回收内存**可能出现以下四种情况之一：
- 回收分区r上面邻接一个空闲分区
- 回收分区r下面邻接一个空闲分区
- 回收分区r上面、下面各邻接一个空闲分区
- 回收分区r不与任何空闲分区相邻

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_31.png)

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_32.png)

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_33.png)

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_34.png)

3.动态分区管理的优缺点

- 相对灵活，没有固定分区中程序数目的限制和程序大小的限制。
- 每道程序总是要求占用主存的连续存储区域，主存中会产生许多碎片（外部碎片）。

4.动态分区分配算法

不论是空闲分区链管理还是空闲分区表管理，链和表中的空闲区都可按一定规则排列，例如按空闲区从大到小排，以方便空闲区的查找和回收。

常用的动态分区管理的分配算法有：

1)首次适应算法（FF）

首次适应算法又称最先适应算法，该算法要求空闲分区按地址递增的次序排列。

在进行内存分配时，从空闲分区表（或空闲分区链）首开始顺序查找，直到找到第一个能满足其大小要求的空闲分区为止。

然后，再按照作业大小，从该分区中划出一块内存空间分配给请求者，余下的空闲分区仍然留在空闲分区表（或空闲分区链）中

特点：优先利用内存低地址端，高地址端有大空闲区。但低地址端有许多小空闲分区时会增加查找开销。

2)循环首次适应算法（NF）

循环首次适应算法又称下次适应算法，它是首次适应算法的变形。空闲分区仍然是按地址递增的次序排列。

该算法在为进程分配内存空间时，从上次找到的空闲分区的下一个空闲分区开始查找，直到找到第一个能满足其大小要求的空闲分区为止。

然后，再按照作业大小，从该分区中划出一块内存空间分配给请求者，余下的空闲分区仍然留在空闲分区表（或空闲分区链）中。

特点：使存储空间的利用更加均衡，但会使系统缺乏大的空闲分区。

3)最佳适应算法（BF）

最佳适应算法要求空闲分区按容量大小递增的次序排列。

在进行内存分配时，从空闲分区表（或空闲分区链）首开始顺序查找，直到找到第一个能满足其大小要求的空闲分区为止。

如果该空闲分区大于作业的大小，则从该分区中划出一块内存空间分配给请求者，将剩余空闲区插入到空闲分区表（或空闲分区链）中的适当位置。

按最佳适应算法为作业分配内存，就能把既满足作业要求又与作业大小最接近的空闲分区分配给作业。

特点：保留了大的空闲区。但分割后的剩余空闲区很小。

4)最坏适应算法(WF)

最坏适应算法要求空闲分区按容量大小递减的次序排列。

在进行内存分配时，先检查空闲分区表（或空闲分区链）中的第一个空闲分区，若第一个空闲分区小于作业要求的大小，则分配失败；

否则从该空闲分区中划出与作业大小相等的一块内存空间分配给请求者，余下的空闲分区仍插入到空闲分区表（或空闲分区链）中的适当位置。

特点：分区分配之后剩下的空闲区域（新空闲区）比较大，但当大作业到来时，其存储空间的申请往往得不到满足。

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_35.png)

在该例子中，采用首次适应算法，申请96K的时候把作业分配给4号分区，申请20K的时候分配给1号分区，但申请200K的时候现有的五个分区都无法满足要求，该作业等待。显然采用首次适应算法进行内存分配，无法满足该作业序列的需求。

但采用最佳适应算法则可以满足该作业序列的需求，申请96K时选中5号分区，5号分区大小与申请空间大小一致，应从空闲分区表中删去该表项；然后申请20K时选中1号分区，分配后1号分区还剩下12K；最后申请200K，选中4号分区，分配后剩下18K。

### 动态可重定位分区分配
连续分配方式中，必须把作业装入到一片连续的内存空间中。这种分配方法能满足多道程序设计的需要，但存在碎片问题。 

碎片也可称为零头，是指内存中无法被利用的存储空间。

**解决碎片问题的办法**：

**拼接**：解决碎片问题的办法之一，即通过移动内存中的进程，把多个分散的小分区拼接成一个大分区，也可称为紧缩或紧凑。

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_36.png)

拼接的缺点是要耗费大量处理机时间。每次拼接之后都必须对移动了的程序或数据进行重定位。

拼接需要解决的技术问题：
- 空闲区放在何处：拼接后的空闲区放在何处不能一概而论，应根据移动信息量的多少来决定。
- 拼接的时机：
  - 每次回收分区时拼接。只有一个空闲区，但拼接频率过高增加系统开销。
  - 找不到足够大的空闲区且系统空闲空间总量能满足要求时拼接。拼接频率小于前者，空闲区管理稍复杂。也可以只拼接部分空闲区。
  
**动态重定位**：拼接后程序在内存的位置发生变化，因此需要动态重定位技术支持。

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_38.png)

动态重定位分区算法与动态分区分配算法基本上相同，差别仅在于：在这种分配算法中增加了紧凑的功能。通常，当该算法不能找到一个足够大的空闲分区来满足用户需求时，如果所有小的空闲分区的容量总和大于用户的要求，这时便须对内存进行“紧凑”。

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_37.png)

### 伙伴系统

固定分区存储管理限制了内存中的进程数，动态分区的拼接需要大量时间，而伙伴系统是一种较为实用的动态存储管理办法。

伙伴系统采用伙伴算法对空闲内存进行管理。该方法通过不断对分大的空闲存储块来获得小的空闲存储块。当内存块释放时，应尽可能合并空闲块。

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_39.png)

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_40.png)

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_41.png)

举例：设系统中初始内存空间大小为1MB，进程请求和释放空间的操作序列为：

进程A申请200KB；B申请120KB；C申请240KB； D申请100KB；

进程B释放；

E申请60KB；

进程A、C释放；

进程D释放；

进程E释放。

那么分配过程示意图如下：

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_42.png)

伙伴系统的缺点：
- 分配和回收时需要对伙伴进行分拆及合并，增加了系统开销。（好于拼接）
- 存储空间有浪费。（如一个进程N申请65KB空间，分配给它的是128KB的空间，浪费了63KB）

---
## 对换

所谓“对换”， 是指把内存中暂时不能运行的进程或者暂时不用的程序和数据，调出到外存上，以便腾出足够的内存空间，再把已具备运行条件的进程或进程所需要的程序和数据，调入内存。

对换是提高内存利用率的有效措施。 

分为 “整体对换”（以进程为单位）和“部分对换”（以页或段为单位）

为了能对对换区中的空闲盘块进行管理，在系统中应配置相应的数据结构，以记录外存的使用情况。
- 空闲分区表
- 空闲分区链

在空闲分区表中的每个表目中应包含两项，即对换区的首址及其大小，它们的单位是盘块号和盘块数。 

进程的换出
- 内存紧张，系统应将某进程换出。 
- 系统首先选择处于阻塞状态且优先级最低的进程作为换出进程。 
进程的换入
- 系统应定时地查看所有进程的状态，从中找出“就绪”状态但已换出的进程，将其中换出时间(换出到磁盘上)最久的进程作为换入进程，将之换入。 

---
## 分页存储管理方式

连续分配方式存在碎片，而紧凑技术开销太大，若能取消作业对存储区的连续性要求，则能较好地解决碎片问题。分页存储管理就是基于这一思想提出的。
分页式存储管理允许把一个作业存放到若干不相邻接的分区中
- 免去移动信息
- 充分利用主存空间

### 页面和页表

在分页存储管理中，将进程的逻辑地址空间划分成若干大小相等的页（或称页面），典型的页面大小为1KB，相应地将主存空间也划分成与页大小相等的块（或称物理块、页框）。在为进程分配存储空间时，总是以块为单位来分配，即将进程中的某一页存放到主存的某一空闲块中。

页面大小的选择：页面的大小应适中。若页面太大，以至和一般进程大小相差无几，则页面分配退化为：分区分配，同时页内碎片也较大。若页面太小，虽然可减少页内碎片，但会导致页表增长。因此，页面大小应适中，通常为2的幂，一般在512B到8KB之间。

为了在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页面映象表，简称页表。

**页表**：记录页面在内存中对应物理块的数据结构。

页表一般存放在内存中。

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_43.png)

页表的作用：实现从页号到物理块号的地址映射

### 地址变换机构

地址变换机构的任务是实现逻辑地址到物理地址的变换，即将逻辑地址中的页号转换为内存中的物理块号。

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_44.png)

**地址计算**：

对于二进制表示的地址，按照前面的地址结构分析，很容易得出页号和页内位移。

对于“十进制”表示的地址，也可以按下面方法计算页号和页内地址。

记A为逻辑地址，L为页面大小，则：

页号：P=int(A/L)； 

页内地址：d=A mod L

例如A＝10000，L＝4096，则P＝2，d＝1808

**地址变换**：

地址变换：将逻辑地址映射为物理地址。

分页系统地址变换的简单描述：利用页表中的物理块号，很容易得出每页所在物理内存的基地址。这些基地址与页内位移组合就形成了物理地址。

例如，页面大小为L，逻辑地址A的页号为P，页内地址为d，P对应的物理块号为F，那么A对应的物理地址＝F×L＋d。

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_45.png)

计算过程如下：

逻辑地址0的页号为0，页内地址为0。根据页表可以查到，页0对应的物理块号为5。因此逻辑地址0变换为物理地址是20 (＝(5×4)+0)。

逻辑地址3的页号为0，页内地址为3。页0对应的物理块号为5。因此逻辑地址3变换为物理地址是23 (＝(5×4)+3)

逻辑地址4的页号为1，页内地址为0。页1对应的物理块号为6。因此逻辑地址4变换为物理地址是 24(＝(6×4)+0)

逻辑地址14变换为物理地址是10 (＝(2×4)+2)

**基本地址变换机构**：

页表通常存放在内存中，为了实现方便，系统中设置了一个页表寄存器存放页表在内存的起始地址和页表的长度。

进程未执行时，页表的起始地址和长度存放在PCB中。当进程执行时，才将页表始址和长度存入页表寄存器中。

**地址变换过程**：

分页地址变换机构自动地将逻辑地址分为页号和页内位移；

将页号与页表长度进行比较，如果页号超过了页表长度，则表示本次所访问的地址已超越进程的地址空间，系统产生地址越界中断；

若未出现越界，则由页表始址和页号计算出相应页表项的位置，从中得到该页的物理块号；

将物理块号与逻辑地址中的页内位移拼接在一起，就形成了访问主存的物理地址。

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_46.png)

**问题1**：设页面大小为1K字节，作业的0、1、2页分别存放在第2、3、8块中。请计算逻辑地址2500对应的物理地址。

答：逻辑地址2500的页号及页内地址为：

2500/1024=2（页号）；2500 %1024＝452（页内地址）；

查页表可知第2页对应的物理块号为8；

将块号8与页内地址452拼接得到物理地址为：

8×1024＋452＝8644。

**问题2**：一分页系统中逻辑地址长度为16位，页面大小为1KB，且第0、1、2、3页依次存放在物理块3、7、11、10中。请计算逻辑地址0A6FH的物理地址。

答：逻辑地址0A6FH的二进制表示如下：

页号      页内地址

000010  1001101111 

由此可知逻辑地址0A6FH的页号为2，该页存放在第11号物理块中，用十六进制表示块号为B，所以物理地址为：

001011  1001101111 ，即2E6FH。

**快表（联想存储器）**

因页表放在主存中，故存取数据时CPU至少要访问两次主存。降低了内存访问速度。

为了提高地址变换速度，可在地址变换机构中增设一个具有并行查找能力的高速缓冲存储器（又称联想存储器或快表），用以存放当前频繁访问的那些页表项。 

**引入快表后的地址变换过程**：

地址变换机构自动将页号与快表中的所有页号进行并行比较，若其中有与此匹配的页号，则取出该页对应的块号，与页内地址拼接形成物理地址。

若页号不在快表中，则再到主存页表中取出物理块号，与页内地址拼接形成物理地址。

同时还应将这次所查到的页表项存入快表中，若快表已满，则必须按某种原则淘汰出一个表项以腾出位置。

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_47.png)

### 两级和多级页表

现代计算机系统都支持非常大的逻辑地址空间，致使页表很大，用连续空间存放页表不现实。

如逻辑地址32位，页面大小4KB（2^12），则页表项为1M个 （2^32/2^12=2^20） ，若每个页表项占4B，则页表要占用4MB（＝220×4B）连续内存空间。

解决方案：两级页表、多级页表、反向页表

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_48.png)

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_49.png)

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_50.png)

**多级页表**

- 对两级页表进行扩充，便可得到三级、四级或更多级的页表。
- 多级页表的实现方式与两级页表类似。
- 但多级页表会影响效率。如二级页表地址变换需三次访问主存，一次访问一级页表、一次访问二级页表、一次访问指令或数据，访问时间加了两倍。

---
## 分段存储管理方式

引入分段存储管理，主要是满足用户需求：

方便编程，模块化程序设计中，程序或数据被划分成若干个大小不等，具有独立逻辑意义的分段。

以分段为单位进行管理，便于共享和保护，可以实现动态链接及段的动态增长。

### 基本原理

在分段存储管理系统中，作业的地址空间由若干个逻辑分段组成，每个分段是一组逻辑意义相对完整的信息集合，每个分段都有自己的名字，每个分段都从0开始编址并采用一段连续的地址空间。

在进行存储分配时，以段为单位分配内存，每段分配一个连续的内存区，但各段之间不要求连续。

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_51.png)

**段表**:为了实现从逻辑地址到物理地址的变换，必须为每个进程建立一个段表，用来记录每段在内存的起始地址及相关信息。其中每个表项描述一个分段的信息，至少包含：段号、段长、段在内存的起始地址。

段表一般存放在内存。

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_52.png)

**地址变换**

为实现从逻辑地址到物理地址的转换，在系统中设置了段表寄存器，用于存放段表始址和段表长度。

为了提高内存的访问速度，也可以使用快表。

**地址变换过程**

进行地址变换时，系统将逻辑地址中的段号S与段表长度进行比较，若段号超过了段表长度则产生越界中断；

否则根据段表始址和段号计算出该段对应段表项的位置，从中读出该段在内存的起始地址，

然后再检查段内地址是否超过该段的段长，若超过则同样发出越界中断信号；

若未越界，则将该段的起始地址与段内位移相加，从而得到了要访问的物理地址。

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_53.png)

设作业分为3段，0、1、2段长度分别为1K、800、600，分别存放在内存6K、4K、8K开始的内存区域。

逻辑地址（1，100）的段号为1，段内位移为100。如何计算其对应的物理地址?

查段表可知第1段在内存的起始地址4K。

将起始地址与段内位移相加，4K＋100＝4196，即物理地址为4196。

### 分段与分页的主要区别

分页管理与分段管理有许多相似之处，两者都采用离散分配方式，都是通过地址映射机构实现地址变换。但两者在概念上也有很多区别，主要表现在：

1.页是信息的物理单位，是为了减少内存碎片及提高内存利用率，是系统管理的需要。段是信息的逻辑单位，它含有一组意义相对完整的信息，分段的目的是为了更好地满足用户的需要。

2.页的大小固定且由系统决定，由硬件把逻辑地址划分为页号和页内地址两部分。段的长度不固定且由用户所编写的程序决定，通常由编译系统在对源程序进行编译时根据信息的性质来划分。

3.分页系统中作业的地址空间是一维的，分段系统中作业的地址空间是二维的。

### 信息共享

存储共享：两个或多个进程共用内存中相同的区域，包括代码共享和数据共享。

分段是信息的逻辑单位，因而实现共享比分页系统方便。

在分页存储管理系统中，信息的共享是通过使多个进程页表项指向同一个物理块来实现的。

在分段存储管理系统中，信息的共享是通过使多个进程的段表项指向同一内存区域实现的。

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_54.png)

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_55.png)

### 段页式存储管理方式

产生背景：结合段式和页式优点、克服二者缺点。

分页系统能有效地提高内存利用率，而分段系统能很好地反映用户要求。如果将这两种存储管理方式结合起来，就形成了段页式存储管理系统。 

段页式存储管理的基本思想：

在段页式存储管理系统中，作业的地址空间首先被分成若干个逻辑分段，然后再将每一段分成若干个大小固定的页面。

将主存空间分成若干个和页面大小相同的物理块，对主存的分配以物理块为单位。

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_56.png)

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_57.png)

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_58.png)

**地址变换过程**：

在进行地址变换时，首先将逻辑地址中的段号S与段表寄存器中的段表长度进行比较，若小于段表长度则表示未越界；

利用段表寄存器中的段表始址和段号求出该段对应段表项的位置，从中得到该段的页表始址；

再利用逻辑地址中的段内页号P获得对应页表项的位置，从中读出该页所在的物理块号，再与页内位移拼接成物理地址。

![example](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_59.png)

在段页式系统中，要想存取访问信息，需要三次访问内存：
- 第一次访问段表
- 第二次访问页表
- 第三次访问信息

为了提高访问主存的速度，应考虑使用联想寄存器。 
