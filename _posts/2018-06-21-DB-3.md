---
layout: post
title: Database——Analysis & Design
date: 2018-06-21
categories: blog
tags: Database
description: Database
---

# 数据库系统——数据库分析与设计

## 前言

该部分的学习笔记来自课本`数据库系统：设计、实现与管理`，是武汉大学计算机学院软件工程专业大二下半学期所学习的一门专业课

---
## 第10章 数据库系统开发生命周期

为了解决软件危机，人们提出了一种结构化的软件开发方法——**信息系统生命周期**，也称为**软件开发生命周期**。对于数据库来说，该生命周期特指**数据库系统开发生命周期**

**信息系统**：在组织机构内用于收集、管理、控制和分发信息的一种资源

而数据库系统是信息系统的基础构件。

数据库系统开发生命周期的各个阶段：

![数据库系统开发生命周期的各个阶段](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/DB_3.jpg)

**数据库规划**：数据库规划是一种管理活动，目的是尽可能高效地展开数据库系统开发生命周期的各个阶段。
- 清晰定义项目的任务描述
- 确定任务目标
- 建立相关标准，明确数据应该如何收集、确定数据的格式、需要什么样的文档以及如何着手进行设计和实现阶段的工作

**系统定义**：定义数据库应用程序的范围和边界，以及主要的用户视图。

**用户视图**：从一个特定的角色（如经理或主管）或者特定的企业应用领域（如销售、人事或库存管理）的角度来定义数据库系统的需求。
- 一个数据库系统可能拥有一个或多个用户视图。
- 在需求收集分析阶段，用户视图能够确保系统不会遗漏主要用户的需求。
- 用户视图的定义包括数据和处理数据的事务。

**需求收集与分析**：收集、分析组织机构内需要数据库系统支持的那部分的信息，用据此确定对新系统的需求。

针对每个主要的用户视图应采集的信息包括：
- 使用或产生的数据
- 这些数据是如何使用或产生的
- 对新数据库系统的其他需求

需求收集与分析阶段要解决的另外一个重要问题是如何处理多个用户视图：
- 集中式方法
- 视图集中方法
- 这两种方法的结合

**集中式方法**：合并所有用户视图的需求，形成对新系统的一组需求。在数据库设计阶段创建一个表示了所有用户需求的数据模型。

**视图集中方法**：每个用户视图的需求都独立列出。在数据库设计阶段，首先针对每个用户视图的需求建立各自的数据模型，然后再加以整合。

### 数据库设计
**数据库设计**：为企业或单位所需数据库系统生成设计方案的过程，该设计方案应能支持该数据库的任务描述和任务目标。

**数据库设计方法**
- 自下而上：从底层的属性入手，通过分析属性之间的关联将它们分别组合成代表实体类型和实体类型之间联系的关系(适用于涉及属性相对较少的简单数据库的设计)
- 自上而下：建模初始仅包含少量的高层实体以及实体之间的联系，然后进一步确定底层的实体、实体之间的联系以及相关属性（更适用于复杂数据库）

**数据建模**
- 理想模型的标准：结构有效性、简洁性、表现力、没有冗余、共享性、可扩展性、完整性、图表化表示

**数据库设计阶段划分**：概念设计、逻辑设计、物理设计三个阶段

**概念数据库设计**：建立概念数据模型，无需考虑实现细节。概念数据模型是基础，是下一阶段——逻辑数据库设计的信息来源。

**逻辑数据库设计**：根据已有的概念数据模型，建立逻辑数据模型，该模型与具体的DBMS以及其他物理因素无关。

**物理数据库设计**：产生数据库在辅存上的实现描述的过程。物理数据库的设计定义了基础关系、文件组织方式和能够提高数据访问效率的索引，以及所有的完整性约束和安全措施。

逻辑/概念数据库设计对应外模式和概念模式；

物理数据库设计对应内模式和物理存储。

### DBMS选择
合适的时机是在概念数据库设计之后，逻辑数据库设计之前

### 应用程序设计
**应用程序设计**：完成用户界面和使用、处理数据库的应用程序的总体设计

---
## 第12章 实体-联系建模
### 实体类型
**实体类型**：能够独立存在的一组具有相同属性的对象

**实体实例**：实体类型中可以对其进行唯一标识的一个对象（我认为课本上的“实体出现”翻译得不够好）

### 联系类型
**联系类型**：实体类型间的一组有意义的关联

**联系实例**：由参与该联系的各个实体类型的一个实例组成的可被唯一标识的关联。

考虑联系类型Has，它表示Branch实体和Staff实体之间的一种关联，即Branch Has Staff，Has联系的每一个联系实例都将一个Branch实体实例和一个Staff实体实例关联在一起。

主关键字能唯一地标识每个实体的实体类型。

**联系类型的度**：参与联系的实体类型的个数

**递归联系**：同一个实体类型以不同的角色多次参与了同一个联系类型，这种联系类型被称为递归联系。

考虑递归联系Supervises,Supervises表示了员工和某位主管之间的关联，而这位主管也同时是该公司的一名员工，也就是说：实体类型Staff两次参与了联系Supervises：第一次参与的角色是一位主管，第二次参与的角色是一名员工（被管理者）。

### 属性
**属性**：实体或联系类型所具有的某一特性。

例如，实体类型Staff的属性有staffNo、name、position和salary

**属性域**：单个属性或多个属性所允许的取值集合。

**属性的分类**
- 简单属性和组合属性
  - 简单属性：由独立存在的单个部分组成的属性（也称为原子属性）
  - 组合属性：由多个部分组成的属性，每个部分都可以独立存在
    - 例如地址这一属性的值可能为（城市，街道，门牌号），即地址这个属性可以划分为更小的部分，那么地址就是一个组合属性
- 单值属性和多值属性
  - 单值属性：在实体类型的每个实例都只取一个单值的属性
  - 多值属性：对于实体类型的某些实例可能取多个值的属性
    - 例如某个公司可能会有多个电话号码
-导出属性：属性的值是从相关的一个或一组属性（不一定来自同一个实体类型）的值导出来的属性
  - 例如通过成本属性和支出属性可以导出收入属性
 
**关键字**

候选关键字：能够唯一标识每个实体实例的最小属性组

主关键字：被指定用来唯一标识实体类型的每个实例的候选关键字

合成关键字：包括两个或两个以上属性的候选关键字

属性的图形化表示：
![属性的图形化表示](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/DB_4.jpg)

### 强实体类型与弱实体类型
**强实体类型**：该实体类型的存在不依赖于其他的实体类型，也称为父实体、所有者实体或支配实体

**弱实体类型**：该实体类型的存在依赖于其他实体类型的存在，也称为子实体、依赖实体或从属实体
- 特征：仅使用该实体类型的属性无法唯一标识每个实体实例
- 例如：实体Preference并没有主关键字，仅使用该实体的属性无法标识实体的实体实例，只有通过Preference的实例和某位客户之间的联系才能唯一地标识每个Preference实体。

### 结构化约束
**多重性**：指一个参与实体类型通过某一联系与另一参与实体类型的某个实例发生关联的出现的数目（或者范围）
- 一对一联系
- 一对多联系
- 多对多联系

多重性由两个独立的约束组成，即基数(cardinality)约束和参与性(participation)约束
- 基数：在指定的联系类型中，一个实体可能参与的联系实例的最大数目
- 参与性：说明所有实体实例是否都参与了联系

### ER模型问题
连接陷阱
- 扇形陷阱：模型给出了两个实体类型之间的一种联系，但在某些实体实例之间存在着多条通路。
  - 例如多条通路表明学生姚文卿既可能是软件学院的学生，也可能是计算机学院的学生，这显然是不可能的，因此出现了扇形陷阱。
- 断层陷阱：模型表明某些实体类型之间存在联系，但某些实体实例之间却不存在通路。
  - 例如无法确定学生姚文卿所在的学院。
  
---
## 第13章 增强的实体-联系建模
### 特殊化/泛化
超类和子类：
- 超类：它的实例包括一个或多个独立的子集，且各独立子集均需在数据模型中单独表示为实体类型。
- 子类：超类包含的独立出现的子集，需要在数据模型中单独表示

属性的继承：子类除了拥有该子类特有的属性外，还拥有超类的所有属性。

实体、实体的子类以及实体的子类的子类等等，这种结构被称为**类型层次**。

一个子类有不止一个超类时，称这个子类为共享子类，这些超类的属性都将被共享子类继承，这种继承称为**多重继承**。

**特殊化**过程：通过标识实体成员之间的差异特征而将这些成员间的差异最大化的过程

**泛化**过程：通过标识实体成员之间的共同特征而将这些成员间的差异最小化的过程

特殊化/泛化的图形表示:

![特殊化/泛化的图形表示](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/DB_5.jpg)

![特殊化/泛化的图形表示](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/DB_6.jpg)

**特殊化/泛化的约束**

对于特殊化/泛化来说，共有两类约束，即参与约束和不相交约束
- 参与约束：限定每个超类的成员是否一定是某个子类的成员
  - 强制的(mandatory)
  - 可选的(optional)
- 不相交约束：描述子类成员之间的联系，说明了超类的某一成员是仅为一个还是同时为多个子类的成员
  - 不相交(Or)
  - 可相交(And)

### 聚合
聚合：表示实体类型之间的“拥有”和“属于”联系，这些实体中有一个表示整体，其他的表示部分

### 组合
组合：一种特殊形式的聚合，表示在实体的关联中，“整体”对“部分”拥有强所有权，且两者的生存期相同。

---
## 第14章 规范化
### 规范化的目的
规范化：生成一组既具有所期望的特性又能满足企业数据需求的关系的技术

规范化产生的关系具有的性质：
- 属性个数最少，且是必需的
- 具有紧密逻辑联系的诸属性均在同一关系中
- 最少的冗余，即每个属性仅出现一次，作为外部关键字的属性除外

### 数据冗余与更新异常

最少的数据冗余带来的好处：
- 能用最少的操作完成对数据库中存储数据的更新，由此可以降低数据库中出现数据不一致的概率
- 减少存储基本关系所需的文件存储空间，从而将成本降到最低

更新异常：
- 插入异常
  - 插入信息时出现的信息不一致性
  - 在向关系StaffBranch中插入一个新的分公司的信息时，该分公司可能目前还没有员工，将员工相关信息设为null，但staffNo为null时会违反实体完整性约束
- 删除异常
  - 在从关系StaffBranch中删除一个元组时，若该元组表示某分公司最后一个员工，则删除元组后，该分公司的信息也丢失了
- 修改异常
  - 修改某个属性时没有完成其他元组中对应信息的更新，产生了不一致
 
### 函数依赖
与规范化相关的一个重要概念是函数依赖，函数依赖描述了属性之间的联系。

假设有一关系模式。具有属性(A,B,C,...,Z)，我们用一个全域关系R=(A,B,C,...,Z)来描述数据库。

**函数依赖**：描述一个关系中属性之间的联系。例如，假设A和B均为关系R的属性，若A中的每个值都和B中的唯一一个值对应，则称B函数依赖于A，记为A→B（A和B可能由一个或多个属性组成）

**决定方**：位于函数依赖箭头左边的属性或属性组。

**完全函数依赖**：假设A和B是某一关系的属性（组），若B函数依赖于A，但不函数依赖于A的任一真子集，则称B完全函数依赖于A

**传递依赖**：假设A、B、C是某一关系的属性，若A→B,B→C,则称C通过B传递依赖于A(假设A并不函数依赖于B或C)

识别函数依赖→例5和例6

利用函数依赖确定主关键字→例7和例8

### 规范化
**第一范式**：属于第一范式的关系，其每一行和每一列相交的位置有且仅有一个值

从非规范的表中消除重复组转化为第一范式的常用方法：
- 在含有重复数据的那些行的空白列上输入合适的数据（平板化处理）
- 将重复数据单独移到一个新的关系中，同时也将原来关系中的关键属性（组）复制到这个新的关系中

**第二范式**：满足第一范式的要求并且每个非主关键字属性都完全函数依赖于主关键字的关系

将1NF转化为2NF的方法：创建一些新的关系，将那些存在部分依赖的非主关键字属性移至其中，并将它们完全函数依赖的那部分主关键字也复制到新的关系中，

**第三范式**：满足第一范式和第二范式的要求并且所有非主关键字属性都不传递依赖于主关键字的关系

将2NF转化3NF的方法：消除传递依赖。如果存在传递依赖，就将传递依赖的属性（组）移到一个新的关系中，并将这些属性的决定方也复制到该关系中。

具体的转化方式要看课本上的例题，这部分很重要，范式的判断和规范化是2015级数据库期末考试的最后一道大题。
