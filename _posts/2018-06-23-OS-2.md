---
layout: post
title: 操作系统——进程的描述与控制
date: 2018-06-23
categories: blog
tags: 操作系统
description: 学习笔记。
---

第二章 进程的描述与控制
===
## 前言

`操作系统原理`是武汉大学计算机学院软件工程专业大二下半学期所学习的一门专业课，教材为西安电子科技大学出版社的`计算机操作系统`第4版，这个专题的博客为该课程的学习笔记

---
### 前趋图和程序执行

**前趋图**：有向无循环图，描述程序执行的前后顺序

**程序顺序执行**：按照先后次序顺序执行，仅当前一程序段执行完之后才运行后一程序段

程序顺序执行时的三个特征：
- 顺序性
- 封闭性
- 可再现性

**程序并发执行**：顺序执行的系统资源利用率很低，因此引入多道程序技术使程序或程序段之间可以并发执行，并发执行的程序之间会形成相互制约的关系。

程序并发执行时的三个特征：
- 间断性
- 失去封闭性
- 不可再现性

### 进程的描述
#### 进程的定义和特征
进程的定义：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。

PCB进程控制块（Process Control Block）用来描述进程的基本情况和活动过程，进而控制和管理进程。

进程除了具有程序所没有的PCB结构外，还具有下面一些特征：
- 动态性（由创建而产生，由调度而执行，由撤销而消亡）
- 并发性
- 独立性（进程是一个能独立运行、独立获得资源和独立接受调度的基本单位）
- 异步性

#### 进程的基本状态及转换
三种基本状态：
- 就绪状态（已分配到除CPU以外的所有必要资源）
- 执行状态（已获得CPU）
- 阻塞状态（发生某事件（I/O 请求、申请缓冲空间等）而暂时无法继续执行）

又引入两种常见的状态：创建状态和终止状态

处于创建状态的进程，获得了所需的资源以及对其PCB的初始化工作完成后，便可由创建状态转入就绪状态。

![](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_1.jpg)

#### 挂起激活操作和进程状态的转换

引入挂起操作，当该操作作用于某个进程时，该进程将被挂起，意味着此时该进程处于静止状态。如果进程正在执行，它将暂停执行；若原本处于就绪状态，则该进程此时暂不接受调度。

与挂起操作对应的操作是激活操作。

具有创建、终止和挂起状态的进程状态图：

![](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_2.jpg)

#### 进程控制块
★进程实体：由程序段、数据段及进程控制块三部分所构成的一个实体。

OS管理的数据结构一般分为：内存表、设备表、文件表和用于进程管理的进程表（进程表又被称为进程控制块PCB，Process Control Block）

PCB的作用：
- 为独立运行基本单位的标志（系统创建新进程时为它建立一个PCB，进程结束时又回收其PCB，进程也随之消亡。系统是通过PCB感知进程的存在的，PCB已成为进程存在于系统中的唯一标志）
- 能实现间断性运行方式（进程因阻塞而暂停运行时，保留CPU现场信息；再次被调度运行时恢复CPU现场信息）
- 提供进程管理所需要的信息
- 提供进程调度所需要的信息
- 实现与其它进程的同步与通信。

PCB所包含的信息：
- 进程标识符（外部标识符：方便用户对进程的访问，内部标识符：方便系统对进程的使用）
- 处理机状态：包括通用寄存器、指令计数器、程序状态字PSW、用户栈指针
- 进程调度信息：包括进程状态、进程优先级、进程调度所需的其它信息、事件
- 进程控制信息：包括程序和数据的地址、进程同步和通信机制、资源清单、链接指针

PCB的组织方式：
- 线性方式，实现简单，开销小，但每次查找都需要扫描整张表
- 链接方式
- 索引方式

### 进程控制
#### 操作系统内核
★通常将一些与硬件紧密相关的模块、各种常用设备的驱动程序以及运行频率较高的模块安排在紧靠硬件的软件层次中，将它们常驻内存，即通常被称为的OS内核。

目的：一是便于对这些软件进行保护，防止遭受其他应用程序的破坏；二是提高OS的运行效率。

处理机的执行状态：系统态和用户态

大多数OS内核都包含了以下两大方面的功能：
- 支撑功能：中断处理、时钟管理和原语操作
  - 原语->原子操作->一个操作中的动作要么全做，要么全不做
- 资源管理功能：进程管理、存储器管理、设备管理

#### 进程的创建
导致一个进程去创建另一个进程的典型事件有四类：

用户登录、作业调度、提供服务、应用请求

进程创建原语的主要功能是为被创建进程建立一个PCB。其算法步骤如下：

1、向系统申请一个空闲PCB结构，若没有则出错返回；

2、为新进程分配资源：为新进程的程序和数据以及用户栈分配必要的内存空间；

3、初始化新进程的PCB：包括标识信息、处理机状态信息、处理机控制信息等；

4、将进程PCB插入相应队列：插入就绪队列。

#### 进程的终止
引起进程终止的事件：
- 正常结束
- 异常结束：超时、内存不足、地址越界、算术错、I/O故障、非法指令等。
- 外界干预：因某种原因需要操作员或系统终止进程；父进程请求终止子进程；父进程终止

进程终止原语的主要功能是撤消一个进程。其算法步骤如下：

1、根据标识符，找到进程的PCB，读出其状态；

2、若被终止进程正处于运行状态，则立即停止该进程的执行，设置重新调度标志；

3、若被终止进程有子孙进程，还应将该进程的子孙进程予以终止；

4、对于被终止进程所占有的资源，或者归还给父进程，或者归还给系统；

5、最后撤消它的PCB：从队列中移出。

#### 进程的阻塞与唤醒
引起进程阻塞的事件：
- 请求系统服务：如请求分配资源但尚无资源分配。
- 等待某种操作：进程必须在该操作完成之后才能继续执行
- 新数据尚未到达：如合作进程之间。
- 无新工作可做：进程已完成了给定任务，新任务未到。
- 当进程等待的事件发生时，由发现者进程将其唤醒。

阻塞原语的主要功能是将进程由执行状态转为阻塞状态。其算法步骤如下：

1、根据当前执行进程的标识符找到PCB；

2、停止执行进程，将进程状态改为阻塞；

3、保存该进程的现场信息到其PCB结构中；

4、将该进程PCB插入到等待队列；

5、转进程调度程序。

唤醒原语的主要功能是将进程唤醒，其算法思想如下：

1、从等待队列中取出相应进程；

2、将该进程状态改为就绪，并将进程插入就绪队列；

3、转进程调度或返回。

阻塞与唤醒的关系：一个进程由执行状态转变为阻塞状态，是这个进程自己调用阻塞原语去完成的。

进程由阻塞状态转变为就绪状态，是另一个发现者进程调用唤醒原语实现的。

一般发现者进程与被唤醒进程是合作的并发进程。

★block原语和wakeup原语是一对作用刚好相反的原语，使用它们时必须成对使用。

#### 进程的挂起与激活
当出现了引起进程挂起的事件时，比如，用户进程请求将自己挂起，或父进程请求将自己的某个子进程挂起时，系统将利用挂起原语将指定进程挂起。
挂起原语的主要功能是将指定进程挂起。其算法思想如下：

1、根据被挂起进程的标识符，找到其PCB；

2、取该PCB的状态；

3、若为运行状态，则停止其执行，改为就绪挂起状态，转进程调度；

若为就绪状态，则改为就绪挂起状态；

若为等待状态，则改为等待挂起状态；

当发生激活进程的事件时，如用户进程或父进程请求激活指定进程，若进程驻留在外存而内存已经有足够的空间，则系统可利用激活原语将外存上被挂起的进程换入内存。
激活原语的主要功能是将指定进程激活。其算法思想如下：

1、将进程状态由挂起改为激活后的状态；

2、就绪挂起改为就绪；

3、等待挂起改为等待；

4、若需要则转进程调度。

### 进程同步
#### 进程同步的基本概念
进程同步的主要任务是使并发执行的进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性。

两种形式的制约关系：
- 相互协作关系（直接制约关系）
  - 要保证相互合作的诸进程在执行次序上的协调
  - 比如输入进程A和计算进程B，共享同一个缓冲区

资源共享关系（间接制约关系，竞争关系）
  - 要保证诸进程互斥地访问临界资源
  - 比如打印机、磁带机这样的临界资源

**临界资源**(Critical Resources, CR)：一段时间内仅允许一个进程使用的资源。

**临界区**：进程中访问临界资源的那段代码。

**互斥**：当一个进程正在访问某共享资源时，就不允许其他进程对其访问。

诸进程应采用互斥方式实现对临界资源的共享。

应互斥使用的资源有：打印机、输入机、磁带机；共享变量、共享数据结构等。

```
while(TRUE)
{
进入区//对欲访问的临界资源进行检查，看它是否正被访问。如果此刻该临界资源未被访问，进程便可进入临界区对该资源进行访问，并设置它正被访问的标志；如果此刻该临界资源正被某进程访问，则本进程不能进入临界区。
临界区//访问临界资源的代码
退出区//将临界区正被访问的标志恢复为未被访问的标志。
剩余区//其它代码
}
```

解互斥问题应遵循的原则：
- 空闲让进：若无进程处于临界区时，应允许一个进程进入临界区。
- 忙则等待：当已有进程进入临界区，其他进程必须等待。
- 有限等待：应保证要求进入临界区的进程在有限时间内进入临界区。
- 让权等待：当进程不能进入自己的临界区时，应释放处理机。

互斥是解决进程间竞争关系的手段，同步是解决进程间协作关系的手段。

互斥是一种特殊的进程同步，即**逐次**使用临界资源。

#### 信号量机制

**一、整型信号量**

Wait操作意味着申请一个资源，Signal操作意味着释放一个资源。Wait和Signal操作也常被称为P操作和V操作。

信号量（Semaphore）是一个整型变量，表示资源数目，可以对其执行P、V原语操作。

```
wait(S){			
while(S<=0)
S--;
}

signal(S){
S++;
}
```

- P操作：如果信号量大于0，对信号量执行--操作，表示申请资源，使信号量自减1；如果信号量等于 0，进程阻塞，等待信号量大于 0；
- V操作：对信号量执行+1操作，表示释放资源，被释放的资源可以用于唤醒阻塞的进程让其完成P操作。

缺点： wait操作中只要是信号量S≤0，就会不断地测试。因此，该机制并未遵循“让权等待”的准则，而是使进程处于“忙等”的状态。

**二、记录型信号量**

记录型信号量是一个记录型数据结构，包含信号量值和一个等待队列，其中信号量值是一个具有非负初值的整型变量，等待队列是一个初始状态为空的队列。

信号量定义:  

```
type semaphore=record
value: integer；     //信号量值
L: list of process； //等待队列
```

wait操作：	设S为一个信号量
```
procedure wait(S)
　　var S：semaphore；
　　begin
　　　S.value:=S.value-1； //表示申请一个资源
　　　if S.value<0 then block(S.L)；//没有空闲资源
　　end 
```

signal操作：
```
procedure signal(S)
　　var S: semaphore；
　　begin
　　　 S.value:=S.value+1； //表示释放一个资源
　　　 if S.value<=0 then wakeup(S.L)；//表示有进程处于等待状态
   end 
```

信号量的物理含义：
- 信号量S.value必须置一次且只能置一次初值，初值不能为负数，通常表示空闲资源的数目。
- S.value>0表示有S. value个资源可用；
- S. value=0表示无资源可用；
- S. value<0则|S. value|表示S等待队列中的进程个数；
- Wait(S)意味着请求一个资源，signal(S)意味着释放一个资源。

在记录型信号量机制中，S.value的初值表示系统中某类资源的数目，因而又成为资源信号量，对它的每次wait操作，意味着进程请求一个单位的该类资源，使系统中可供分类的该类资源数减少一个。当S.value<0时，表示该类资源已经分配完毕，因此进程应调用block原语进行自我阻塞，放弃处理机，并插入到信号量链表S->list中（遵循了“让权等待”原则），此时S->value的绝对值表示在该信号量链表中已阻塞进程的数目。

而对信号量的每次signal操作表示执行进程释放一个单位资源，使系统中可供分类的该类资源数增加一个，故S.value++操作表示资源数目+1。若+1后仍有S.value≤0，则表示该信号量链表中仍有等待该资源的进程被阻塞，故还应调用wakeup原语，将S->list链表中的第一个等待进程唤醒。

如果S.value的初值为1，表示只允许一个进程访问临界资源，此时的信号量转化为互斥信号量，用于进程互斥。

**三、AND型信号量**（非考点）

记录型信号量适用于进程之间共享一种临界资源的场合。但是在很多应用中，一个进程需要先获得两种或多种共享资源后，才能执行其任务。AND型信号量集适合同时需要多种资源，且每种占用一个时的情况。

基本思想是：
- 把进程在整个运行其间所要的临界资源，一次性全部分配给进程，待该进程使用完临界资源后再全部释放。
- 只要有一个资源未能分配给该进程，其他可以分配的资源，也不分配给他。亦即要么全部分配，要么一个也不分配，这样做可以消除由于部分分配而导致的进程死锁。为此，在wait操作中增加了一个“AND”条件

**四、一般型信号量集**（非考点）

适合于同时需要多种资源，且每种占用的数目不同，且可分配的资源还存在临界值（该种资源数目少于临界值是不允许分配）时的处理。

基本思想：对AND型信号量集进行扩充，允许一次申请多个资源，而且在分配之前，测试某资源的数量是否大于临界值。

#### 信号量的应用
一、利用信号量实现进程互斥：为使多个进程能互斥地访问某临界资源，只须为临界资源设置一个互斥信号量mutex，其初值为1；在每个进程中将临界区代码置于wait(mutex)和signal(mutex)之间。

![互斥访问临界区的描述](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_3.png)

如果2个进程共享一个临界资源，信号量的取值范围是1、0、-1
- 若没有进程使用临界资源，S=1
- 若只有1个进程使用临界资源，S=0
- 若1个进程使用临界资源而另1个进程等待使用临界资源，S=-1

二、利用信号量实现前趋关系

![1](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_4.png)

![2](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/OS_5.png)

#### 管程机制（非考点）
信号量机制的引入解决了进程同步的描述问题，但信号量的大量同步操作分散在各个进程中不便于管理，还有可能导致系统死锁。
  - 如生产者消费者问题中将P、V颠倒可能死锁。

为此Dijkstra于1971年提出：把所有进程对某一种临界资源的同步操作都集中起来，构成一个所谓的秘书进程。凡要访问该临界资源的进程，都需先报告秘书，由秘书来实现诸进程对同一临界资源的互斥使用。

1973年Hansen和Hoare又把秘书进程的思想发展为管程的概念。

Hansen为管程所下的定义是：管程定义了一个数据结构和在该数据结构上能为并发进程所执行的一组操作，这组操作能同步进程和改变管程中的数据。
  - 这些数据结构是对相应临界资源的抽象

**管程**：代表临界资源的数据及在其上操作的一组过程

管程的构成：
- 管程的名字
- 局部于管程的共享数据结构（变量）
- 对共享数据结构进行的一组操作（函数）
- 对局部于管程的数据设置初始值的语句

管程的基本特性：
- 管程中的共享变量仅能由管程内定义的函数所访问，在管程外部是不可见的。
- 一个进程只有通过调用管程内的函数（进入管程）才能间接访问共享变量。
- 每次仅允许一个进程在管程内执行某个函数。即规定管程互斥进入。
- 由于管程是一个语言成分，所以管程的互斥访问完全由编译程序在编译时自动添加上，无需程序员关心，而且保证正确。

### 经典进程的同步问题
下一个博客专门用来讲解这一问题

### 进程通信
由于进程的互斥与同步，需要在进程间交换一定的信息，但这些是低级进程通信，之所以低级是因为①效率低②通信对用户不透明
在进程之间需要传送大量数据时，应利用OS提供的高级通信工具，主要特点是
（1）使用方便，通信过程对用户透明
（2）高效地传送大量数据
2.6.1进程通信的类型
四大类：共享存储器系统、管道通信系统、消息传递系统、客户机-服务器系统
2.6.1.1 共享存储器系统
基于共享数据结构的通信方式（低效，只适于传递少量数据）
基于共享存储区的通信方式
2.6.1.2 消息传递系统
在消息传递系统中，进程间的数据交换以消息为单位，程序员直接利用系统提供的一组通信命令（原语）来实现通信。
分为直接通信方式和间接通信方式
（1）直接通信方式
消息缓冲通信是直接通信方式的一种实现。系统通过两条通信原语Send及Receive进行通信。
消息缓冲通信的实现：
发送进程应先在自己的工作区中设置一个发送区，把欲发送的消息填入其中；
然后再用发送原语将其发送到接收进程，将其挂在接收进程的消息队列(消息链)上；
接收进程调用接收原语从自己的消息队列中摘下第一个消息，并将其内容复制到自己的消息接收区内。
消息缓冲区的数据结构如下：
   struct message 
    {
             sender;   发送者进程标识符
             size;       消息长度
             text;       消息正文
             next;      指向下一个消息缓冲区的指针
    }
在进程的PCB中增加涉及通信的数据结构：           	
mq      	消息队列队首指针
mutex  	    消息队列互斥信号量，初值为1
sm      	消息队列资源信号量，初值为0

发送原语描述：
procedure send(receiver, a) /*receiver为接收者标识号，a为发送区首址*/
{
       向系统申请一个消息缓冲区；
       将发送区a中的消息复制到该消息缓冲区中；
	    找到接收进程的PCB；获得接收者进程的内部标识符j;
       wait(j.mutex)；      /*互斥使用消息队列*/
       把消息挂到接收进程消息队列的尾部；
       signal(j.mutex)；
       signal(j.sm)；          /*接收进程消息队列长度加1*/
}
接受原语描述：
void  receive(b)  /* b为接收区首址 */
{
          wait(j.sm)； /* j为调用进程的内部标识符 */
          wait(j.mutex)；
          将消息队列中的第一个消息移出；
          signal(j.mutex)；
          将消息复制到接收区b；
}
（2）间接通信方式
邮箱分为：私有邮箱、共有邮箱、共享邮箱
在利用信箱通信时，在发送进程和接收进程之间，存在以下四种关系：
一对一关系、多对一关系、一对多关系、多对多关系

2.6.1.3 管道通信系统
通过连接读进程和写进程的共享文件来实现读写进程之间通信。
管道(pipeline)是连接读写进程的一个特殊文件，允许进程按先进先出方式传送数据，也能使进程同步执行操作。
发送进程以字符流形式把大量数据送入管道，接收进程从管道中接收数据，所以叫管道通信。
管道机制应提供以下三方面的协调能力：
互斥：进程对通信机构的使用应该互斥，一个进程正在使用某个管道写入或读出数据时，另一个进程就必须等待。	
同步：管道长度有限，发送信息和接收信息之间要实现正确的同步关系，当写进程把一定数量的数据写入管道，就去睡眠等待，直到读进程取走数据后，把它唤醒。
存在：发送者和接收者双方必须能够知道对方是否存在，如果对方已经不存在，就没有必要再发送信息。
2.6.1.4 客户机-服务器系统
主要的实现方法：套接字、远程过程调用、远程方法调用

2.7线程的基本概念
2.7.1线程的引入
如果说在操作系统中引入进程的目的是为了使多个程序并发执行，提高资源利用率和系统吞吐量；那么，在操作系统中引入线程，则是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性。
进程具有两个属性：①拥有资源的独立单位②调度和分派的基本单位
为使进程并发执行，则必须进行诸如创建、撤消、切换等一系列操作，这些操作涉及到资源管理，所花费的时空开销较大，限制了并发度的提高，为此引入了线程。

线程：是进程内的一个执行单元（执行路径）
是系统独立调度和分派的基本单位
资源分配的实体还是进程
原来进程的两个属性分开处理

在传统操作系统的单线程进程(模型)中，进程和线程概念可以不加区别 。
在多线程进程(模型)中，线程是进程中的实体，一个进程可以拥有多个线程，一个线程必须有一个父进程。 

在单线程进程模型中，进程的表示包括它的进程控制块和用户地址空间，以及在进程执行中管理调用/返回行为的用户栈和系统栈。
在多线程进程中，仍然有与进程相关的是PCB和用户地址空间，而每个线程都有独立的堆栈和线程控制块TCB

2.7.2线程与进程的区别
调度
在传统的操作系统中，作为拥有资源的基本单位和独立调度、分派的基本单位都是进程。而在引入线程的操作系统中，则把线程作为调度和分派的基本单位，而进程作为资源拥有的基本单位
并发性
在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，使得操作系统具有更好的并发性，从而能更加有效地提高系统资源的利用率和系统的吞吐量。
拥有资源
进程是系统中拥有资源的一个基本单位。线程自己基本上不拥有资源，只拥有一点在运行时必不可少的资源（如程序计数器、一组寄存器和栈）
系统开销
线程的创建、撤销，切换，同步和通信方面的开销都优于进程。
独立性
每个进程都拥有一个独立的地址空间和其他资源；但是同一进程中的不同线程共享进程的内存地址空间和资源

2.7.3 线程的状态
三个状态：执行状态、就绪状态、阻塞状态
多线程OS中的进程属性：（1）进程是一个可拥有资源的基本单位
（2）多个线程可并发执行。
（3）进程已不是可执行的实体。

2.8线程的实现
2.8.1线程的实现方式
2.8.1.1内核支持线程KST
内核支持线程是指依赖于内核，由操作系统内核完成创建、撤消和切换的线程。
核心维护进程和线程的上下文；线程之间的切换需要核心支持；以线程为基础进行调度。 
2.8.1.2用户级线程ULT
用户级线程仅存在于用户空间中。对于这种线程的创建、 撤消、线程之间的同步与通信等功能，都无须利用系统调用来实现。
对于用户级线程的切换，通常是发生在一个应用进程的诸多线程之间，这时，也同样无须内核的支持。
比较用户级线程和内核支持线程
线程的调度与切换速度：内核级线程的调度与切换与进程类似，但开销小些；用户级线程切换无需进入内核，因而切换快。
系统调用：内核级线程调用系统调用时，OS将其看成是该线程的行为，因而阻塞该线程；而用户级线程调用系统调用时，OS将其看成整个进程的行为，若阻塞则阻塞整个进程。
线程执行时间：在只有用户级线程的系统中，调度以进程为单位，若进程内线程多则执行时间相对少；内核级线程系统中，调度以线程为单位。
适应性：用户级线程可以在任何操作系统中运行，但内核级线程只能在支持它的OS中运行。

2.8.1.3组合方式
（1）一对一模型
是为每一个用户线程都设置一个内核控制线程与之连接，当一个线程阻塞时，允许调度另一个线程运行。在多处理机系统中，则有多个线程并行执行。
该模型并行能力较强，但每创建一个用户线程相应地就需要创建一个内核线程，开销较大，因此需要限制整个系统的线程数。
（2）多对一模型
将多个用户线程映射到一个内核控制线程，为了管理方便，这些用户线程一般属于一个进程，运行在该进程的用户空间，对这些线程的调度和管理也是在该进程的用户空间中完成。当用户线程需要访问内核时，才将其映射到一个内核控制线程上，但每次只允许一个线程进行映射。
主要优点是线程管理的开销小，效率高，但当一个线程在访问内核时发生阻塞，则整个进程都会被阻塞，而且在多处理机系统中，一个进程的多个线程无法实现并行。 
（3）多对多模型
结合上述两种模型的优点，将多个用户线程映射到多个内核控制线程，内核控制线程的数目可以根据应用进程和系统的不同而变化，可以比用户线程少，也可以与之相同。 

2.8.2线程的实现
2.8.2.1内核支持线程的实现
系统在创建一个新进程时，便为它分配一个任务数据区PTDA(Per Task Data Area)，其中包括若干个线程控制块TCB空间。
在每一个TCB中可保存线程标识符、优先级、线程运行的CPU状态等信息。虽然这些信息与用户级线程TCB中的信息相同，但现在却是被保存在内核空间中。 

2.8.2.2用户级线程的实现
用户级线程是在用户空间实现的。所有的用户级线程都具有相同的结构，它们都运行在一个中间系统的上面。
当前有两种方式实现的中间系统:
1)运行时系统
2)内核控制线程
