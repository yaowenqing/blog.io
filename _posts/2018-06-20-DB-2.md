---
layout: post
title: 数据库系统——关系模型与语言
date: 2018-06-20
categories: blog
tags: 数据库
description: 学习笔记。
---

第二部分 关系模型与语言
===
## 前言

该部分的学习笔记来自课本`数据库系统：设计、实现与管理`，是武汉大学计算机学院软件工程专业大二下半学期所学习的一门专业课

---
## 第四章 关系模型

### 基本术语
**关系**是由行和列组成的表

**属性**是关系中命名的列。在关系模型中，用**关系**来保存数据库所描述对象的信息。关系用二维表表示，表中的每一行对应一个单独的记录，表中的每一列则对应一个属性。无论属性如何排列，都是同一个关系，因此所表达的含义也是一样的。

**域**是一个或多个属性的取值集合。关系模型中必须给每一个属性定义一个域，不同属性的域可以互不相同，也可以让两个或两个以上的属性共用同一个域。用户可以通过域来的集中定义属性取值的含义与范围。

![关系Branch和关系Staff中某些属性对应的域](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/DB_1.jpg)

**元组**：关系中的每一行称为元组。

**维数**：关系的维数是指关系所包含属性的个数，只有一个属性的关系的维数为1，称为一元关系或是一元组。有两个属性的关系称为二元关系，有三个属性的关系称为三元关系。

**基数**：关系的基数是指它所包含元组的个数。

可选关系模型术语（可以相互替换）

|正式术语| 可选术语1|可选术语2 |
|:--:|:--:|:--:|
|关系 | 表 | 文件 |
|元组 | 行 | 记录 |
|属性 | 列 | 字段 |

### 数据中的关系
**关系模式**：用一组属性和域名对定义的具名的关系

设属性A1、A2、……An所对应的域分别为D1、D2、……Dn，那么集合{A1：D1，A2：D2，……An：Dn}就是一个关系模式

将关系模式中的域替换为实例对象的子集称为关系实例。

**关系数据库模式**：关系模式的集合，集合中的每个关系都应有不同的名字，设R1、R2、……Rn为一系列关系模式，那么关系数据库模式R如下：

>R{R1、R2、……Rn}

**关系的性质**

一个关系通常有如下性质
- 有一个关系名，同一关系模式中各关系不能重名
- 关系中的每一个单元格都确切地包含单个值
- 每个属性都有一个不同的名字
- 同一属性中的各个值都取自相同的域
- 各元组互不相同，不存在重复元组
- 属性的顺序不重要
- 在不考虑有很多元组的关系的访问效率的情况下，元组的顺序也不重要

### 关系关键字

**超关键字SK**（Super Key）：一个属性或属性集合，能唯一地标识出关系中的每个元组

**候选关键字CK**（Candidate Key）：本身是超关键字且其任何真子集都不是超关键字
- 唯一性
- 不可约性

一个关系可能有多个候选关键字。当一个关键字中包含多个属性时，就称它为合成关键字

**主关键字PK**（Primary Key）：被选用于唯一标识关系中各元组的候选关键字

**外部关键字FK**（Foreign Key）：当一个关系中的某个属性或属性集合与另一个关系（也可能就是自己）的候选关键字匹配时，就称这个属性或属性集合为外部关键字
### 完整性约束
之前提到的域是一个或多个属性的取值集合，从而存在**域约束**（domain constraint），限定了关系中各个属性的取值集合。

此外还有两条重要的完整性规则
- 实体完整性
- 引用完整性

**空**代表对一个元组当前取值还不知道或是不可用的属性值

**实体完整性**：在基本关系中，主关键字的属性不能为空

**引用完整性**：如果在关系中存在某个外部关键字，则它的值要么与主关系中的某个元组的候选关键字取值相等，要么全都为空。
>引用完整性的举例：关系Staff中的branchNo指向主关系Branch中的BranchNo属性。那么如果Branch关系中没有BranchNo为xxx的记录，Staff就不能创建一个分公司编号为xxx的员工记录。但是Staff可以创建一个分公司编号为空的新员工记录（这表明加入了一个新员工，但这个新员工还没有被分配到某个特定的分公司中。）

关系模型的完整性约束除了上面的两条完整性规则外，还有**多样性**和**一般性约束**,多样性在第12章介绍。

**一般性约束**：由数据库用户或者数据库管理员所指定的附加规则，它约束企业的某些方面。
### 视图
在这篇博客中，迄今为止我们所谈到的关系都是基本关系

**基本关系**：与概念模式中的一个实体相对应的具名关系，它的元组都存储在数据库的物理结构中。

**视图**：对一个或多个基本关系进行关系操作得到的动态结果。视图是一个无需存在于数据库当中，但却可以根据某个特定用户需要在需要时再生成的虚关系。

视图的内容被定义成基于一个或多个基本关系的查询，对视图所进行的任何操作都自动地转换成对导入它的关系进行操作，视图是动态的，这意味着对导出视图的基本关系的修改将立即反映在视图上。通过视图进行更新存在一些约束，下面是大多数系统允许通过视图进行更新操作的条件：

- 如果视图由一个基本关系的简单查询生成，而且它还包含了基本关系中的主关键字或者候选关键字，则可以通过这个视图进行更新操作。
- 不允许对涉及多个基本关系的视图进行更新。
- 如果视图的生成中涉及聚集或者分组操作，则不允许通过这个视图进行更新。

---
## 第五章 关系代数

关系代数的五个基本运算：选择、投影、笛卡尔乘积、集合并、集合差

可以从这五个基本运算演化出另外三个重要的运算：连接、集合交、除运算。

**连接运算**：通常只需要将满足特定条件的笛卡尔乘积结合起来，因此一般采用连接运算来代替笛卡尔乘积运算。
- θ连接
- 等接（θ连接的特例）
- 自然连接
- 外连接
- 半连接

**聚集运算**：类似于报表底部的合计
- COUNT：返回相关联属性值的个数
- SUM：返回相关联属性值的总和
- AVG：返回相关联属性值的平均值
- MIN：返回相关联属性值的最小值
- MAX：返回相关联属性值的最大值

**分组运算**：类似于报表中的小计

课本P90开始：

|例题序号 | 内容 |
|:--:|:--:|
|1 | 单个关系：最基本的选择运算 |
|2 | 单个关系：最基本的投影运算 | 
|3 | 集合运算：并运算+投影 |
|4 | 集合运算：集合差运算+投影 |
|5 | 集合运算：集合交运算+投影 | 
|6 | 笛卡尔乘积+投影 |
|7 | 等接运算 |
|8 | 自然连接 | 
|9 | 左外连接 |
|10 | 半连接 |
|11 | 除法运算 |
|12 | 聚集运算(COUNT、SUM、AVG) |
|13 | 分组运算 |

关系代数运算小结：

![关系代数运算小结](https://raw.githubusercontent.com/yaowenqing/blog.io/master/img/DB_2.jpg)
---
## 第六章 SQL：数据操作

### 简单查询
**SELECT**语句用于检索并显示一个或多个数据库表中的数据

使用**FROM**来给出所要查询的表

使用**WHERE**过滤满足条件的行

使用**GROUP BY**将具有相同属性值的行分成组

使用**HAVING**过滤满足条件的组

使用**SELECT**指定查询结果中出现的列

使用**ORDER BY**指定查询结果的顺序

|例题序号 | 内容 |
|:--:|:--:|
|1 | 检索所有的列和所有的行 |
|2 | 从所有行中检索指定的列 | 
|3 | 使用DISTINCT消除重复 |
|4 | 在SELECT的过程中计算字段 |
|5 | 将比较运算作为WHERE查找条件 |
|6 | 将复合比较运算作为WHERE查找条件 | 
|7 | 将范围BETWEEN作为WHERE查找条件 |
|8 | 将IN/NOT IN作为WHERE查找条件 |
|9 | 将模式匹配LIKE作为WHERE查找条件 |
|10 | 空查找条件 | 
|11 | 使用ORDER BY子句对查询结果排序 |
|12 | 多列降序排序 |
|17 | 使用GROUP BY子句对查询结果分组 |
|18 | 使用HAVING子句进行分组约束 |

### 使用SQL聚集函数

**COUNT**：返回指定列中数据的个数

**SUM**：返回指定列中数据的总和，只能用于数值字段

**AVG**：返回指定列中数据的平均值，只能用于数值字段

**MIN**：返回指定列中数据的最小值

**MAX**：返回指定列中数据的最大值

COUNT(\*)是COUNT的特殊用法，计算表中所有行的数目，而不管是否有空值或重复出现

|例题序号 | 内容 |
|:--:|:--:|
|13 | COUNT(\*)的使用 |
|14 | COUNT(DISTINCT)的使用 | 
|15 | COUNT和SUM的使用 |
|16 | MIN、MAX和AVG的使用 |

### 子查询
将SELECT语句完全嵌套在另一个SELECT语句中，内部SELECT语句的结果用在外部语句中以决定最后的查询结果

|例题序号 | 内容 |
|:--:|:--:|
|19 | 用于相等判断的子查询 |
|20 | 用于聚集函数的子查询 | 
|21 | 嵌套子查询：IN的使用 |

### ANY和ALL
关键字**ANY**和**ALL**用于产生单个列的子查询。若子查询前缀关键字ALL，那么仅当子查询产生的所有值都满足条件时条件才为真。若为ANY，那么子查询产生的任何一个值满足条件时即为真。

|例题序号 | 内容 |
|:--:|:--:|
|22 | ANY/SOME的使用 |
|23 | ALL的使用 | 

### 多表查询
要把来自多个表的列组合到结果表时，就需要用到连接操作。

|例题序号 | 内容 |
|:--:|:--:|
|24 | 简单连接 |
|25 | 排序连接 | 
|26 | 三表连接 |
|27 | 按多个列分组|

**连接运算的计算过程**：从概念上看，使用连接的SELECT语句的查询过程如下：

（1）形成FROM子句中指定表的笛卡尔乘积

（2）如果存在WHERE子句，对乘积表的每一行运用查找条件，保留那些满足条件的行，用关系代数术语来说，这个操作是对笛卡尔乘积的一种限制。

（3）对于每个剩下的行，确定SELECT列表中每一项的值，并形成查询结果中的一行

（4）如果指定了SELECT DISTINCT，则消除结果中重复的行（从关系代数看，步骤3和4相当于把第二步得到的限制在SELECT列表列上进行投影）

（5）如果存在ORDER BY子句，则根据要求对查询结果进行排序

**内连接**：连接操作通过配对相关的行来组合两个表中的数据，如果表中某一行不匹配另一表的任何行，那么这行将从结果表中删除。

**外连接**：不匹配的行也出现在结果表中，没有的数据用NULL来表示

|例题序号 | 内容 |
|:--:|:--:|
|28 | 左外连接 |
|29 | 右外连接 | 
|30 | 全外连接 |

### EXISTS和NOT EXISTS
**EXISTS**为真当且仅当子查询返回的结果表至少存在一行，当子查询返回的结果表为空时则为假，**NOT EXISTS**则正好相反。

|例题序号 | 内容 |
|:--:|:--:|
|31 | 使用EXISTS的查询 |

### 合并结果表
SQL中，可用标准的并、交和差集合操作将多个查询结果表合并成一个查询结果表

- A和B两个表的并操作是一个包括两个表中所有行的表
- A和B两个表的交操作是一个包括两个表中共有行的表
- A和B两个表的差操作是一个包括那些在A中而不在B中的行的表

用于集合操作的表必须满足的要求：两个表具有**并相容性**，即必须有相同的结构，两个表必须包含数目相同的列，对应的列具有相同的数据类型和长度。


|例题序号 | 内容 |
|:--:|:--:|
|32 | UNION的使用 |
|33 | INTERSECT的使用 |
|34 | EXCEPT的使用 |

### 数据库更新
增删改的操作

|例题序号 | 内容 |
|:--:|:--:|
|35 | 使用INSERT在数据中插入新行 |
|36 | 默认插入方式 |
|37 | 在INSERT语句中加入SELECT子句 |
|38 | 更新所有行 |
|39 | 更新指定的行 |
|40 | 更新多个列 |
|41 | 删除指定行 |
|42 | 删除所有行 |

---
## 第七章 SQL：数据定义
### 完整性增强特性
完整性约束的五种类型：
- 必须有值的数据
- 域约束
- 实体完整性
- 引用完整性
- 一般性约束

### 数据定义
- 创建数据库
- 创建表（例1）
  - CONSTRAINT约束
- 修改表定义（例2）
  - ALTER语句
  - 添加/删除列+添加/删除约束+设置/删除列默认值
  - RESTRICT和CASCADE的区别：
    - 使用RESTRICT对表进行DROP的删除操作时，如果某列被另外的数据库对象引用，则SQL拒绝进行这一操作
    - 使用CASCADE进行DROP操作时，自动从所有引用该列的数据库对象中删除这一列，此操作级联进行。即从引用对象中删除此列时，SQL检查这一列是否又被其他对象引用，如果是则在那儿继续将其删除，一直这样进行下去。
- 删除表（DROP TABLE）
  - RESTRICT：如果存在任何其他对象依赖于将要删除的表，拒绝DROP操作
  - CASCADE：存在依赖的情况下也允许DROP，同时自动删除所有依赖的对象（包括依赖于这些对象的对象）
- 创建索引
- 删除索引

### 视图
**视图**：为了得到另一个关系而对基关系进行一次或多次关系操作所得到的动态结果。视图是虚关系，即在数据库中不存在，需要时根据特定用户的要求临时生成。 

**视图的可更新性**：为了使视图可更新，对于任何一个行或列，DBMS必须都能追溯到其源表中相应的行或列。

**视图分解**：将对视图的查询和用于视图定义的查询合并，同意转换为对底层基表的查询。每次DBMS进行视图查询时都必须进行视图分解。

**视图物化**：一种视图分解的方法，即把视图第一次查询时的结果存储为数据库中的临时表（比每一次重新计算视图快得多，但缺点在于需实时维持临时表的一致性）
 
**WITH CHECK OPTION**
- 如果指定了WITH LOCAL CHECK OPTION，那么在该视图或由该视图直接或间接导入的视图上进行行插入或更新操作时，不允许行迁移出视图，除非该行也迁移出底层视图或表。
- 如果指定了WITH CASCADE CHECK OPTION（默认设置），那么在该视图或由该视图直接或间接导入的视图上进行行插入或更新操作时都不允许行迁移出该视图。

|例题序号 | 内容 |
|:--:|:--:|
|3 | 创建水平视图 |
|4 | 创建垂直视图 |
|5 | 分组或连接视图 |
|6 | WITH CHECK OPTION使用举例 |

**视图的优缺点**：
- 优点
  - 数据独立性
  - 实时性
  - 提高了安全性
  - 降低了复杂性
  - 方便
  - 用户化
  - 数据完整性
- 缺点
  - 更新局限性
  - 结构局限性
  - 性能开销
  
### 事务
**事务的四个特性ACID**：
- 原子性（Atomicity）
- 一致性（Consistency）
- 隔离性（Isolation）
- 持久性（Durability）

### 自主访问控制
**自主访问控制**：每个用户被授予对特定的数据库对象的适当的访问权利（或权限）

**强制访问控制**：每个数据库对象被赋予特定分级（例如，绝密、秘密、机密、不保密），每个主体被赋予指定的许可证级别

**GRANT**语句将数据库对象的权限授予特定用户，而**REVOKE**语句用于撤销GRANT语句所授予的权限。

|例题序号 | 内容 |
|:--:|:--:|
|7 | 授予所有权限 |
|8 | 授予特定权限 |
|9 | 授予所有用户特定的权限 |
|10 | 撤销所有用户的特定权限 |
|11 | 撤销给定用户的特定权限 |
